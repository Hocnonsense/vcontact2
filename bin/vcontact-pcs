#!/usr/bin/env python
"""vContact-pcs - Copyright 2014 Guilhem Doulcier.

vcontact-pcs is a tool to cluster proteins using MCL. It generates csv
files as output that can directly be used with vcontact. ::

    Output:
        output_contigs.csv
        output_pcs.csv
        output_profiles.csv

See also: vcontact.

This program is distributed under the term of the GNU General Public
Licence v3 (or later) with ABSOLUTELY NO WARRANTY. This is free
software, and you are welcome to redistribute it.

"""

import logging
import pandas
import os
import argparse

import vcontact.protein_clusters
import vcontact

parser = argparse.ArgumentParser(description=__doc__,formatter_class=argparse.RawDescriptionHelpFormatter,)

gen_opt = parser.add_argument_group('General Options')

gen_opt.add_argument('-o', '--output-base', dest='basename', type=str, help='Output basename')

gen_opt.add_argument('-b', '--blast-file', type=str,
                     help='Blast results file in CSV or TSV format. Used for generating the profiles.')

gen_opt.add_argument('-p', '--proteins', type=str,
                     help='A file linking the protein name (as in the blast file) and the contigs names (csv or tsv)')

gen_opt.add_argument('-m', '--mode', type=str, choices=['ClusterONE', 'MCL'], default='ClusterONE',
                     help='Blast results file in CSV or TSV format. Used for generating the profiles.')

one_opt = parser.add_argument_group('ClusterONE Options')

one_opt.add_argument('--max-overlap', default=0.8, type=float, dest='overlap',
                     help='Specifies the maximum allowed overlap between two clusters.')

one_opt.add_argument('--penalty', default=2.0, type=int, dest='penalty',
                     help='Sets a penalty value for the inclusion of each node. It can be used to model the possibility'
                          ' of uncharted connections for each node, so nodes with only a single weak connection to a '
                          'cluster will not be added to the cluster as the penalty value will outweigh the benefits of '
                          'adding the node')

one_opt.add_argument('--haircut', default=0.1, type=float, dest='haircut',
                     help='Apply a haircut transformation as a post-processing step on the detected clusters. A haircut'
                          ' transformation removes dangling nodes from a cluster.')

mcl_opt = parser.add_argument_group('MCL Options')

mcl_opt.add_argument('-i', '--inflation', default=2.0, type=float,
                     help='Inflation parameter to define proteins clusters with MCL. (default: 2.0)')

misc_opt = parser.add_argument_group('Misc. Options')

misc_opt.add_argument('-v', '--verbose', action="count", default=-1,
                      help='Verbosity level : -v warning, -vv info, -vvv debug, (default: debug)')

misc_opt.add_argument('-f', '--force-overwrite', action="store_true", help='Overwrite existing files')

options = parser.parse_args()

# Logging config
log_levels = [logging.WARNING,logging.INFO,logging.DEBUG]

logging.addLevelName(logging.WARNING, "\033[1;31m%s\033[1;0m" % logging.getLevelName(logging.WARNING))
logging.addLevelName(logging.ERROR, "\033[1;41m%s\033[1;0m" % logging.getLevelName(logging.ERROR))
logging.addLevelName(logging.INFO, "\033[1;42m%s\033[1;0m" % logging.getLevelName(logging.INFO))
logging.addLevelName(logging.DEBUG, "\033[1;43m%s\033[1;0m" % logging.getLevelName(logging.DEBUG))

# Create logger with 'spam_application'
logger = logging.getLogger('vcontact')
logger.setLevel(log_levels[options.verbose])
ch = logging.StreamHandler()
ch.setLevel(log_levels[options.verbose])
ch.setFormatter(logging.Formatter('%(levelname)s:%(name)s: %(message)s'))
logger.addHandler(ch)


def main(args):
    # Load the proteins <-> contigs associations...
    logger.info("Loading proteins...")
    proteins_df = pandas.read_csv(args.proteins, sep=',', header=0)
    logger.debug("Read {} proteins from {}".format(len(proteins_df), args.proteins))

    if args.mode == 'ClusterONE':
        pcs_fn = "{}_one_{}_{}_{}.clusters".format(args.basename, args.overlap, args.penalty, args.haircut)
    elif args.mode == 'MCL':
        pcs_fn = "{}_mcl{}.clusters".format(args.basename, int(args.inflation * 10))
    else:
        pcs_fn = False
        logger.error("A mode must be selected. Use ClusterONE or MCL to generate PCs.")
    
    # Run clustering tool on the blast results...
    if (args.mode == 'MCL') and (not os.path.exists(pcs_fn) or args.force_overwrite):
        pcs_fn = vcontact.protein_clusters.make_protein_clusters_mcl(args.blast_file, args.basename, args.inflation)
    elif (args.mode == 'ClusterONE') and (not os.path.exists(pcs_fn) or args.force_overwrite):
        pcs_fn = vcontact.protein_clusters.make_protein_clusters_one(args.blast_file, args.basename, args.overlap, args.penalty, args.haircut)
    else:
        logger.debug("File {} exists and will be used. Use -f to overwrite.".format(pcs_fn))

    # Load the clusters...
    logger.info("Loading the clusters...")
    proteins, clusters, profiles, contigs = vcontact.protein_clusters.build_clusters(pcs_fn, proteins_df, args.mode)

    # Export csv files... 
    logger.info("Saving files...")  # Save the dataframes

    for name, df in [("proteins", proteins), ("contigs", contigs), ("pcs", clusters)]:
        fn = "{}_{}.csv".format(args.basename, name)
        index_id = name.strip('s') + '_id'
        if not os.path.exists(fn) or args.force_overwrite:
            df.set_index(index_id).to_csv(fn)
        else:
            logger.debug("File {} exists and will be used. Use -f to overwrite.".format(fn))

    profiles_fn = "{}_profiles.csv".format(args.basename)
    if not os.path.exists(profiles_fn) or args.force_overwrite:
        profiles.to_csv("{}_profiles.csv".format(args.basename), index=False)
    else:
        logger.debug("File {} exists and will be used. Use -f to overwrite.".format(profiles_fn))

if __name__ == "__main__":
    print("\n{:=^80}\n".format("This is vcontact-pcs {}".format(vcontact.__version__)))
    main(options)
